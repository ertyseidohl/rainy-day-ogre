<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: unit.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: unit.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** 
 * Contains the base unit javascript class prototype PUnit 
 * @author mcverry
 */

// IIFE
// immediately invoked function expression
// things bound to the "exports" variable are global (bound to window),
// everything else is scoped private
;(function(exports){

	var damageTable = [
		["NE", "NE", "NE", "NE", "D", "X"],
		["NE", "NE", "D", "D", "X", "X"],
		["NE", "D", "D", "X", "X", "X"],
		["D", "D", "X", "X", "X", "X"],
		["D", "X", "X", "X", "X", "X"],
        ["X", "X", "X", "X", "X", "X"]
	];


	/**
	 * @memberof PUnit
     * @static 
     *
     * @desc  this method rolls a 6 sided die to determine the which damage method
     * to be applied to the supplied unit using dmaageTable 
     *
     * @param {PUnit} unit - the unit to apply the damage roll too
     * @param {int} ratio - the pre-calculated attack to defense ratio
     * @param {function} cb - the ux callback function
     * @returns {boolean}  true
     */
	var doDamage = function(unit, ratio, cb){
		roll = Math.floor((Math.random() * 6));
		switch(damageTable[ratio][roll]) {
			case "NE":
				unit.noEffect();
				cb("NE");
				break;
			case "D":
				unit.disable();
				cb("D");
				break;
			case "X":
				unit.kill();
				cb("X");
				break;
		}

		return true;
	};

    /** 
     *  Creates a base PUnit
     *  @class PUnit
     */
    exports.PUnit = function(options) {
        if (options == null) { options = {};}
        
        /** unit's base attack points,
         * @member {int} 
         * @memberOf PUnit
         * access with getAttack() 
         * @see getAttack */
        this.attack = options.attack || 0;
        
        /** unit's base range distance,
         * @member {int}
         * @memberOf PUnit
         * access with getRange() 
         * @see getRange*/
        this.range = options.range || 0;
        
        /** unit's base defense points  
         * @member {int} 
         * @memberOf PUnit
         * access with getDefense() 
         * @see getDefense */
        this.defense = options.defense || 0;
        
        /**  unit's base preattack move distance,
         * @member {int} 
         * @memberOf PUnit
         * access with getPreMovement 
         * @see getPreMovement */
        this.premove = options.premove || 0;
        
        /** unit's base postattack move distance,
         * @member {int} 
         * @memberOf PUnit
         * access with getPostMovement() 
         * @see getPostMovement*/
        this.postmove = options.postmove || 0;

        /** can the unit pass through walls 
         * @member {boolean} 
         * @memberOf PUnit 
         * @see getPassThruWalls
         */
        this.passThruWalls = options.passThruWalls || false;
        
        /** the unit's name
         * @member {String}
         * @memberOf PUnit */
        this.name = options.name || "";

        /** the unit's type (THESE ARE NOT WELL DEFINED) 
         * @member {String} 
         * @memberOf PUnit
         * @see getType */
        this.type = options.type || "";

        /** the unit's position, 
         * @member {Tile}
         * @memberOf PUnit
         * @see getTil
         * note that the position object, Tile, can be further abstracted :) */
		this.tile = options.tile || {i : -1, j : -1};

        /** stores if the unit dead (and should be removed)  
         * @member {boolean} 
         * @memberOf PUnit
         * @see isDead */
		this.dead = false;

        /** stores how many turns the unit is disabled for  
         * @member {int} 
         * @memberOf PUnit
         * @see isDisabled */
		this.disabledTurns = 0;
        
        /** how many times hs the unit moved this turn?
         * @member {int} 
         * @memberOf PUnit
         * @see hasMoved
         * @see timesMoved
         * */
	    this.moved = 0;
        
        /** stores if the unit attacked
         * @member {boolean} 
         * @memberOf PUnit.prototype
         * @see hasAttacked */
        this.attacked = false;
    };

    /**
     *  Private method for reseting the unit at the start of
     *  its owners turn
     */
	exports.PUnit.prototype.nextTurnReset = function() {
		this.moved = 0;
		this.attacked = false;
        
        if (this.disabledTurns > 0) {
            this.disabledTurns -= 1;
        }
	};

    /*
     * Attack Results
     */
	
    /**
     *  This method should be overrided by subclasses to
     *  execute a noeffect attack result on this unit
     */
    exports.PUnit.prototype.noEffect = function() {};
	
    /**
     * this method should be overrided by subclasses to modify
     * the behavior of a disable attack result.
     * @returns {boolean} - false to indicate the unit did not die
     */
    exports.PUnit.prototype.disable = function() {
        return false;
    };

	exports.PUnit.prototype.kill = function() {
        this.dead = true;
        return true;
    };
    
    exports.PUnit.prototype.getAttack = function() {
        return this.attack; 
    };

    exports.PUnit.prototype.getDefense = function() {
        return this.defense; 
    };
	
    exports.PUnit.prototype.getRange = function() { 
        return this.range; 
    };

    /**
     * @returns {int} spaces to move before an attack
     */
	exports.PUnit.prototype.getPreMovement = function() { 
        return this.premove; 
    };

    /**
     * @returns {int} spaces to move after an attack
     */
	exports.PUnit.prototype.getPostMovement = function() { 
        return this.postmove; 
    };

    /**
     *  @returns {boolean} returns if the unit is dead
     */
    exports.PUnit.prototype.isDead = function() {
        return this.dead;
    }

    /**
     * @returns {boolean} if the unit is disabled this turn
     */
    exports.PUnit.prototype.isDisabled = function() {
        return (this.disabledTurns > 0);
    }

    /**
     *  @returns {boolean} if the unit has attacked this turn
     */
    exports.PUnit.prototype.hasAttacked = function() {
        return this.attacked;
    }

    /** 
     *  @returns {int} the number of times it moved this turn 
     */
    exports.PUnit.prototype.hasMoved = function() {
        return this.moved;
    }   

    /**
     *  @returns {Tile} the unit's position
     */
	exports.PUnit.prototype.getTile = function() { 
        return this.tile;
    };

    /**
     * Generalized unit selection (enables multipart units to work)
     * @returns {PUnit[]} [this]
     */
    exports.PUnit.prototype.selectForAttack = function() {
        return [this];
    }

	exports.PUnit.prototype.isValidPreMoveTarget = function(tile) {
        return Util.getDistance(this.getTile(), tile) &lt;= this.getPreMovement();
	};

	exports.PUnit.prototype.isValidPostMoveTarget = function(tile) {
		return Util.getDistance(this.getTile(), tile) &lt;= this.getPostMovement();
	};

	exports.PUnit.prototype.isValidMoveTarget = function(tile) {
		if (this.moved == 1) {
            return this.isValidPostMoveTarget(tile);
		} else if (this.moved == 0) {
			return this.isValidPreMoveTarget(tile);
		}
	};

    exports.PUnit.prototype.canAttack = function(unit){
        return !this.hasAttacked() &amp;&amp; this.isValidAttackTarget(unit);
    };
	exports.PUnit.prototype.isValidAttackTarget = function(unitOrTile) {
        var tile = null;
        try{
            tile = unitOrTile.getTile();
        } catch (e)
        {
            if (e instanceof TypeError) {
                tile = unitOrTile;
            }
        }
        return Util.getDistance(this.getTile(), tile) &lt;= this.getRange();
    };

    exports.PUnit.prototype.moveToTile = function(tile) {
        if (this.isValidMoveTarget(tile)){
            this.tile = tile;
            this.moved += 1;
            return true;
        }
        return false;
    };

    //Get the ratio from an array of attacking units against this unit
    exports.PUnit.prototype.getDamageRatio = function(attackerlist) { 
        attackSum = attackerlist.reduce(function(accum, elem, index, array) {
            return accum + elem.getAttack();
        }, 0);
        def = this.getDefense();
        ratio = Math.floor(attackSum / this.getDefense());
        if (ratio > 5) {ratio = 5;}
        return ratio; 
    };

    //do damage to unit
    exports.PUnit.prototype.takeDamage = function(attackerlist, cb ) {
        ratio = this.getDamageRatio(attackerlist);
        return doDamage(this, ratio, cb);
    };


})(window);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="PUnit.html">PUnit</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0-dev</a> on Wed Mar 25 2015 10:06:43 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
